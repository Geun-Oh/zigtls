# TLS 1.3 구현 작업 상세 설명서 (한국어)

본 문서는 `/Users/ohyeong-geun/zig/zigtls/_task.md`의 요구사항을 실제 구현 관점에서 확장 설명한다.
각 항목은 다음 3가지를 고정적으로 다룬다.
- 구현 필요성: 왜 이 기능/요건이 반드시 필요한가
- 필요 기술: 무엇을 알아야/준비해야 구현 가능한가
- 구현 절차: 어떤 순서로 구현하고 검증하는가

## 1. 목표와 품질 기준
### 구현 필요성
- TLS 라이브러리는 "연결 성공"만으로는 충분하지 않다. 악의적 입력, 비정상 네트워크, 인증서 오류, 상태 전이 공격까지 안전하게 처리해야 운영 환경에서 사용 가능하다.
- 프로덕션 등급의 핵심은 기능 완성도보다 "실패 시 안전하게 거절(fail-closed)"과 "재현 가능한 검증 체계"다.

### 필요 기술
- RFC 8446(TLS 1.3) 규격 해석 능력.
- 암호 스위트, 키 스케줄(HKDF), 인증서 체인 검증, 경고(alert) 처리 지식.
- Zig의 명시적 메모리 관리 및 오류 처리 모델.

### 구현 절차
1. RFC 요구사항을 MUST/SHOULD 중심으로 추출한다.
2. 모듈(레코드/핸드셰이크/키스케줄/상태/인증서)별 책임을 고정한다.
3. 성공 경로와 실패 경로의 수용 기준을 문서화한다.
4. 상호운용·퍼징·부정 테스트를 릴리스 게이트로 연결한다.

## 2. 범위 정의(v1 MUST, v2 SHOULD)
### 구현 필요성
- TLS는 기능이 많아 범위가 흔들리면 보안 핵심이 지연된다.
- v1에서 반드시 필요한 기능과 이후 확장 항목을 분리해야 일정/품질/검증이 통제된다.

### 필요 기술
- 스코프 관리(요구사항 우선순위화).
- 기능 토글, 단계적 릴리스 전략.

### 구현 절차
1. v1 MUST: TLS 1.3 전용, 클라이언트/서버, Sans-I/O, 핵심 인증서 검증, PSK/티켓, 0-RTT 보호 정책.
2. v1 제외: TLS 1.2, QUIC glue, 실험 확장.
3. v2 SHOULD: AIA fetch, 형식검증 확장, 준-정형 검증.
4. 변경 요청은 "보안 영향 + 상호운용 영향 + 테스트 비용"으로 평가 후 반영.

## 3. 아키텍처 비협상 요구사항

## 3.1 Sans-I/O 코어
### 구현 필요성
- 네트워크 I/O와 프로토콜 로직이 결합되면 테스트 결정성이 떨어지고 런타임 종속이 커진다.
- Sans-I/O는 테스트/퍼징/이식성의 기반이다.

### 필요 기술
- 바이트 버퍼 기반 상태 처리.
- 입출력 어댑터 계층 분리 설계.
- 동기/비동기 런타임 통합 패턴.

### 구현 절차
1. 코어 엔진 API를 `encrypted_in -> tls_events/out_frames` 형태로 설계한다.
2. 소켓 읽기/쓰기 코드는 어댑터로 분리한다.
3. 동일 테스트 벡터를 sync/async 양쪽 어댑터에 재사용한다.
4. 코어에서 시스템 콜이 발생하지 않는지 코드 리뷰 게이트를 둔다.

## 3.2 명시적 메모리 할당 정책
### 구현 필요성
- TLS는 연결 수가 증가하면 메모리 정책이 성능/안정성의 핵심 병목이 된다.
- 핫패스에서 힙 할당이 반복되면 지연/단편화/예측 불가능성이 증가한다.

### 필요 기술
- Zig allocator 모델.
- `ArenaAllocator` 수명 관리.
- 고정 버퍼/풀 기반 재사용 전략.

### 구현 절차
1. "할당이 필요한 API는 allocator 인자를 받는다"를 인터페이스 규칙으로 고정.
2. 핸드셰이크 임시 데이터는 `ArenaAllocator`로 묶어 종료 시 일괄 해제.
3. 레코드 경로는 고정 버퍼 또는 풀 재사용으로 per-record 할당 제거.
4. 연결당 최대 메모리 상한을 문서+런타임 체크로 강제.

## 3.3 선형화된 상태 머신(FSM)
### 구현 필요성
- TLS 취약점 상당수는 상태 전이 혼선(예상치 못한 메시지 수용)에서 발생한다.
- 명시적 FSM은 감사 가능성과 안전한 실패 처리를 높인다.

### 필요 기술
- 상태/이벤트 전이 테이블 설계.
- alert 매핑(어떤 위반에 어떤 alert를 보낼지) 정책.

### 구현 절차
1. 클라이언트/서버 상태를 enum으로 고정.
2. `(현재상태, 수신메시지) -> (다음상태|alert)` 테이블 구현.
3. 불법 전이는 즉시 fatal alert와 연결 종료.
4. 상태 전이 단위테스트와 부정테스트를 필수화.

## 3.4 암호 경로 규율
### 구현 필요성
- 자체 저수준 암호 구현은 보안 리스크가 크다.
- 상수시간(constant-time) 위반은 키 유출로 이어질 수 있다.

### 필요 기술
- 표준/검증된 암호 프리미티브 사용.
- 상수시간 비교/처리 관례.
- 민감 데이터 zeroization.

### 구현 절차
1. 허용 프리미티브 목록을 고정하고 외부 임의 구현 유입 금지.
2. 비밀 의존 경로에 대해 분기/메모리 접근 패턴 검토.
3. 키/시크릿 수명 종료 시 명시적 소거.
4. 릴리스 빌드에서 동작 동일성 및 부채널 위험 재검토.

## 4. 프로토콜 기능 요구사항

## 4.1 TLS 1.3 코어
### 구현 필요성
- 기본 핸드셰이크와 레코드 보호가 정확하지 않으면 모든 상위 기능이 무의미하다.

### 필요 기술
- AEAD(AES-GCM, ChaCha20-Poly1305), SHA-256/384, HKDF.
- transcript hash와 Finished 검증 로직.

### 구현 절차
1. 필수 cipher suite 3종 우선 구현.
2. early/handshake/master/traffic secrets 계산 경로 구현.
3. Finished verify_data 비교를 상수시간으로 처리.
4. KAT + RFC 벡터 기반 검증 추가.

## 4.2 고급 플로우(HRR, KeyUpdate, close_notify)
### 구현 필요성
- HRR 누락은 상호운용성 저하로 직결된다.
- KeyUpdate 미구현은 장기 연결 보안 저하를 유발한다.
- `close_notify` 처리 미흡은 truncation attack 표면이 된다.

### 필요 기술
- 키교환 그룹 재협상 처리.
- traffic secret 갱신 절차.
- alert 기반 정상 종료 판정.

### 구현 절차
1. HRR 수신/재시도/재계산(트랜스크립트 포함) 구현.
2. KeyUpdate 요청/응답 및 송수신 키 동기 갱신 구현.
3. TCP FIN만으로 정상 종료로 판단하지 않도록 정책 강제.
4. 종료 경로 부정테스트(중간 절단, alert 누락) 추가.

## 4.3 세션 재개와 0-RTT
### 구현 필요성
- 재개는 지연 감소에 유효하지만, 0-RTT는 재전송 공격 위험이 있다.
- 기본 비활성화와 엄격한 anti-replay 없이는 안전한 운영이 어렵다.

### 필요 기술
- PSK binder 검증.
- 티켓 수명/윈도우 정책.
- Bloom filter 등 재전송 탐지 구조.
- 애플리케이션 계층의 idempotent 표시 API.

### 구현 절차
1. binder 검증 실패 시 즉시 거절.
2. 0-RTT 기본 OFF, 명시적 설정 시에만 허용.
3. 서버 측 anti-replay 저장소(Bloom + 만료 정책) 구현.
4. 조기 데이터 허용 대상을 API로 제한.
5. 재전송 시나리오 부정테스트를 CI에 포함.

## 4.4 양자내성 전환 준비
### 구현 필요성
- 하이브리드 KEX는 장기 데이터 보호 관점에서 전략적 요구사항이다.
- 지금 즉시 기본 활성화보다 "안전한 통합 경로" 확보가 중요하다.

### 필요 기술
- 하이브리드 그룹 협상/키셰어 직렬화.
- 기존 ECDHE + ML-KEM 결합 처리.

### 구현 절차
1. 그룹 협상 인터페이스를 확장 가능하게 설계.
2. `X25519MLKEM768` 통합 경로를 기능 플래그로 구현.
3. 상호운용성과 성능 기준 충족 전까지 gated 유지.
4. 벤치마크/상호운용 결과를 릴리스 기준에 연결.

## 5. 인증서/신뢰 검증 요구사항

## 5.1 RFC 5280 핵심 검증
### 구현 필요성
- TLS 사고의 다수는 핸드셰이크 자체보다 인증서 검증 미흡에서 발생한다.
- Basic Constraints, KU/EKU, SAN, Name Constraints 누락은 신뢰 모델 붕괴로 이어진다.

### 필요 기술
- X.509 파싱/체인 빌딩.
- 정책 OID/KU/EKU 해석.
- 도메인 이름 검증 규칙.

### 구현 절차
1. 체인 요소별 CA 조건/경로 길이 제약 검증.
2. 용도별 KU/EKU 필터링(서버/클라이언트 인증 맥락 구분).
3. SAN 우선 호스트명 검증 강제.
4. Name Constraints 평가 추가.
5. 정상/오류/경계 케이스 테스트 세트 구성.

## 5.2 OCSP Stapling
### 구현 필요성
- 폐기된 인증서 수용을 줄이기 위해 리보케이션 신호가 필요하다.
- stapling은 지연과 프라이버시 비용을 줄이면서 신선도 검증을 제공한다.

### 필요 기술
- OCSP 응답 파싱/서명 검증/유효기간 평가.
- fail-closed vs soft-fail 정책 제어.

### 구현 절차
1. stapled OCSP가 있으면 구조/서명/시간 유효성 검증.
2. 정책에 따라 실패 처리(하드 실패 또는 소프트 실패).
3. 정책 기본값과 운영 가이드 문서화.

## 5.3 신뢰 저장소 통합
### 구현 필요성
- 운영환경마다 루트 인증서 로딩 방식이 다르므로 일관된 전략이 필요하다.

### 필요 기술
- 플랫폼별 trust anchor 로딩.
- 사용자 지정 번들 병행 처리.

### 구현 절차
1. 플랫폼 로더와 커스텀 번들 로더를 분리 구현.
2. 우선순위/병합 정책을 명확화.
3. 재현 가능한 테스트용 번들 세트 유지.

## 6. API/모듈 설계
### 구현 필요성
- 보안 라이브러리는 API 모호성이 오용으로 직결된다.
- 고수준 편의 API와 저수준 제어 API를 분리해야 사용성과 통제가 동시에 확보된다.

### 필요 기술
- 강타입 설정 객체.
- 오류 분류 체계.
- 모듈 경계 설계.

### 구현 절차
1. 최소 모듈(`record`, `handshake`, `keyschedule`, `state`, `alerts`, `certificate_validation`, `session`) 경계 고정.
2. 설정 객체에 안전 기본값(0-RTT OFF, 강한 cipher 우선) 적용.
3. 오류 타입을 decode/alert/cert/policy/internal로 분리.
4. 디버그 키 로그는 명시적 플래그 없이는 비활성.

## 7. 보안 하드닝 체크리스트
### 구현 필요성
- 구현 완료 후 하드닝이 아니라, 릴리스 전 필수 게이트로 강제해야 취약점 누락을 줄일 수 있다.

### 필요 기술
- 파서 경계검사, 중복 확장 방지, 다운그레이드 신호 검증.
- 사이드채널 리뷰 방법론.

### 구현 절차
1. 파서 길이/중복/불법 조합 거절 규칙 구현.
2. downgrade protection 검증 테스트 추가.
3. alert 수준/종류를 TLS 1.3 의미론에 맞게 정합.
4. 비밀 수명 주기 생성-사용-소거 점검표 운영.

## 8. 검증 전략과 릴리스 게이트

## 8.1 테스트 계층
### 구현 필요성
- 단일 테스트 방식으로는 TLS 품질을 보장할 수 없다.

### 필요 기술
- 단위테스트, 부정테스트, 상호운용 테스트, 퍼징, 회귀 코퍼스 관리.

### 구현 절차
1. 단위테스트: HKDF 라벨, transcript, FSM 전이.
2. 부정테스트: 잘못된 binder/서명/메시지 순서/길이.
3. 상호운용: OpenSSL/BoringSSL/rustls/NSS 매트릭스.
4. 퍼징: 핸드셰이크/레코드/상태변이 입력.
5. 크래셔는 회귀 코퍼스에 영구 편입.

## 8.2 BoGo 요구사항
### 구현 필요성
- BoGo는 TLS 구현의 사실상 표준 부정 시나리오 검증군이다.

### 필요 기술
- BoringSSL runner 호환 shim.
- 테스트 분류/원인 추적 리포팅.

### 구현 절차
1. shim으로 러너 인자와 라이브러리 API 연결.
2. 카테고리별 pass/fail 집계 자동화.
3. critical failure 잔존 시 릴리스 차단.

## 8.3 출하 금지 조건(Release Gate)
### 구현 필요성
- "거의 됨" 상태로 출시되는 위험을 차단해야 한다.

### 필요 기술
- 품질 게이트 자동화(CI).
- 보안 이슈 triage 프로세스.

### 구현 절차
1. RFC 매트릭스 완결 여부를 CI 체크에 연결.
2. interop/fuzz/security 결과를 필수 통과 조건으로 강제.
3. 예외 허용 시 근거 문서와 만료일을 의무화.

## 9. 성능/자원 목표
### 구현 필요성
- 보안과 함께 지연/처리량/메모리 상한을 만족해야 실제 서비스에 적용 가능하다.

### 필요 기술
- 벤치마크 하네스.
- 프로파일링/핫패스 분석.
- zero-copy 지향 처리.

### 구현 절차
1. P50/P99 핸드셰이크 지연 기준 설정.
2. cipher별 처리량 측정 루틴 구축.
3. 연결당 메모리 사용량 모니터링.
4. 핫패스 복사/할당 제거를 우선 최적화.

## 10. 단계별 실행 플랜
### 구현 필요성
- 기능 의존성이 강한 영역이므로 단계가 뒤섞이면 재작업 비용이 크다.

### 필요 기술
- 이행 순서 설계, 마일스톤 관리.

### 구현 절차
1. Phase 0: RFC 추적 행렬/모듈 경계/오류 체계 확정.
2. Phase 1: Sans-I/O 코어 + 기본 핸드셰이크.
3. Phase 2: HRR/KeyUpdate/PSK/확장 + 인증서 심화.
4. Phase 3: 0-RTT anti-replay/OCSP/트렁케이션 방어/사이드채널 점검.
5. Phase 4: BoGo/interop closure + 퍼징 안정화 + 성능 튜닝 + 릴리스 사인오프.

## 11. 산출물 정의
### 구현 필요성
- 산출물이 명확해야 팀 간 인수인계와 품질 검토가 가능하다.

### 필요 기술
- 문서화 표준, CI 아티팩트 관리.

### 구현 절차
1. `docs/rfc8446-matrix.md` 작성 및 유지.
2. `src/tls13/` 모듈 구조 정착.
3. interop/fuzz 스크립트와 CI 워크플로 관리.
4. 보안 하드닝 체크리스트/운영 런북 제공.

## 12. 완료 정의(DoD)
### 구현 필요성
- 완료 기준이 없으면 품질 판단이 개인 해석에 의존한다.

### 필요 기술
- 측정 가능한 체크리스트.
- 증적(테스트 로그/리포트/문서) 관리.

### 구현 절차
1. RFC 추적 행렬 100% 연결 확인.
2. 필수 프로토콜 기능(HRR, KeyUpdate 포함) 구현 확인.
3. 인증서 검증 기본 정책 활성 확인.
4. BoGo/interop/fuzz/부정테스트 통과 확인.
5. 보안/성능 수용 기준 충족 증적 첨부.

## 13. 실무 적용 시 권장 운영 규칙
### 구현 필요성
- 구현 완료 후 운영 단계에서의 오동작/오탐/성능저하를 예방해야 한다.

### 필요 기술
- 관측성(로그/메트릭), 장애 대응 절차, 보안 공지 대응.

### 구현 절차
1. handshake 실패 원인 코드와 alert를 구조화 로그로 남긴다.
2. 재개율, 경고 유형, KeyUpdate 이벤트를 메트릭화한다.
3. 보안 이슈 접수-분석-완화-공개 프로세스를 문서화한다.
4. 릴리스마다 회귀 코퍼스와 interop 결과를 비교 보존한다.
